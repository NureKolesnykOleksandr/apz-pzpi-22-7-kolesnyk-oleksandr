Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
 
 
  
Кафедра ПІ
 

 
Дисципліна «Архітектура програмного забезпечення»
Практична робота №1
«Шаблон (патерн) проєктування Prototype»
 
 
  
 
Виконав:
ст. гр. ПЗПІ-22-7
Колесник О.А	 	Прийняв:
ст. викл. кафедри ПІ
Сокорчук І.П
 

 
Харків – 2025
1 ІСТОРІЯ ЗМІН

№	Дата 	Версія	Опис змін	Автор
1	03.05.25	0.1	Було створено розділ «Завдання».	Колесник Олександр
2	03.05.25	0.1	Було створено розділ «Опис виконаної робо-ти».	Колесник Олександр
3	03.05.25	0.1	Було створено розділ «Висновки з роботи»	Колесник Олександр
4	05.05.25	0.3	Було створено розділ «Додаток А»	Колесник Олександр
5	07.05.25	0.4	Було створено розділ «Додаток Б»	Колесник Олександр

2 ЗАВДАННЯ
У рамках практичної роботи №1 з дисципліни «Архітектура програмного забезпечення» було завдання дослідити патерн проєктування Prototype. Необхідно було вивчити його структуру, основні принципи та застосування в реальних проєктах. Зокрема, важливо було зрозуміти взаємодію між Prototype та реальним об'єктом, а також коли і чому доцільно застосовувати цей патерн. Завдання також включало оцінку переваг і недоліків патерну Prototype та розвиток навичок аналізу та представлення технічної інформації.

3 ОПИС ВИКОНАНОЇ РОБОТИ
У межах виконання роботи було детально досліджено патерн проєктування "Prototype" (Прототип). Цей патерн належить до групи порожніх або креаційних шаблонів, і його головне завдання — оптимізувати процес створення нових об’єктів у програмному середовищі. Розробка систем із використанням патерна Prototype дозволяє гнучко копіювати об'єкти без необхідності створювати їх з нуля, що особливо корисно у випадках, коли ініціалізація нового екземпляра є дорогою або складною.
Prototype працює за принципом створення нових об’єктів шляхом клонування вже існуючих. На відміну від традиційного підходу, де нові об'єкти створюються за допомогою ключового слова new, патерн використовує метод clone, який дозволяє скопіювати всі необхідні пара-метри та властивості з існуючого об’єкта. Такий підхід зменшує кількість залежностей у коді та робить створення нових екземплярів більш передбачуваним і контрольованим. Особливо це важливо для програм, що працюють з конфігураційними або складно структурованими об’єктами.
У реалізації патерна ключовим є абстрактний прототип, який визначає інтерфейс для клонування. На його основі створюються конкретні класи, які реалізують механізм копіювання. Після створення базового об’єкта його можна використовувати як шаблон для подальших копій, кожна з яких буде незалежною, але з аналогічним станом або поведінкою. Це дозволяє легко масштабувати об'єкти в рамках одного контексту, не порушуючи загальної архітектури програми.
Особливої уваги під час проєкту було приділено варіантам клону-вання. Визначено, що існують два основні підходи: поверхневе та глибоке копіювання. Поверхневе клонування створює новий об’єкт, копіюючи лише значення полів, що не містять вкладених об'єктів. У випадку наявності таких об'єктів копіюється лише посилання на них, а не самі значення, що може призвести до спільного використання ресурсів. Натомість глибоке копіювання створює повноцінну незалежну копію всіх вкладених структур, що забезпечує повну ізоляцію між прототипом і новим екземпляром. Такий підхід є більш надійним, але вимагає додаткових витрат ресурсів.
Завдяки простоті й ефективності патерн Prototype був обраний для реалізації одного з механізмів у рамках програмного забезпечення, роз-робленого в межах цієї роботи. Зокрема, він був використаний для копіювання об'єктів налаштувань, які часто змінюються, але потребують збереження попередніх станів. У процесі реалізації було створено базовий інтерфейс IPrototype, що містить метод Clone(), а також конкретні класи, які реалізують цей інтерфейс та повертають власні копії. Такий підхід дозволив скоротити час на створення нових об’єктів і спростив підтримку коду в умовах динамічних змін.
У підсумку, впровадження патерна Prototype дозволило підвищити ефективність роботи з об'єктами, що мають складну структуру або потре-бують багаторазового відтворення. Крім того, зменшення залежності від конструктора дало змогу більш гнучко управляти життєвим циклом об’єктів. Такий підхід виявився корисним у випадках, де потрібне ство-рення великої кількості схожих об’єктів із мінімальними змінами, наприклад, у графічних редакторах, системах налаштувань або конфігуруванні сценаріїв.
4 ВИСНОВКИ З РОБОТИ
Висновки щодо патерну Proxy демонструють його ключову роль у сучасному програмуванні. Головною перевагою цього патерну є зручний механізм контролю доступу до об'єктів, що дозволяє реалізовувати додаткові перевірки автентифікації та авторизації без змін основного коду. Важливою особливістю є оптимізація продуктивності через кешування результатів і ліниве завантаження ресурсів, що особливо актуально при роботі з віддаленими сервісами або складними обчисленнями. Патерн також ефективно інкапсулює складні операції, спрощуючи архітектуру системи.
Однак варто враховувати й певні обмеження Proxy. Додаткові шари абстракції можуть ускладнити код, а додаткові перевірки іноді знижують продуктивність простих операцій. Найефективніше Proxy застосовується для кешування запитів до БД або API, захисту критичних об'єктів, реалізації відкладених операцій та логування викликів. Особливу цінність цей патерн представляє для розподілених систем і додатків з підвищеними вимогами до безпеки, забезпечуючи гнучкість архітектури при збереженні її чистоти.
 
ДОДАТОК А
Відеозапис доповіді на YouTube: https://youtu.be/W-NAMdvIGIo
Хронологічний опис доповіді:
00:01 Початок
00:10 Вступ 
00:32 Визначення патерну Prototype
00:52 Структура патерну 
01:18 Переваги патерну Prototype 
01:45 Недоліки патерну Prototype 
02:10 Застосування патерну 
02:31 Прикладу коду(Інтерфейс) 
02:49 Приклад коду(ConcretePrototype)
03:12 Приклад коду(Глибоке копіювання) 
03:29 Висновки 
04:14 Використані джерела 
ДОДАТОК Б
Слайди презентації доповіді 
 
Рисунок Б.1 – Титульний слайд презентації
 
Рисунок Б.2 – Вступ
 
Рисунок Б.3 –  Визначення патерну Prototype
 
Рисунок Б.4 –  Структура патерну
 
Рисунок Б.5 –  Переваги патерну
 
Рисунок Б.6 –  Недоліки патерну
 
Рисунок Б.7 – Застосування патерну
 
Рисунок Б.8 – Прикладу коду (Інтефейс IPrototype)
 
Рисунок Б.9 – Приклад коду (ConcretePrototype)
 
Рисунок Б.10 – Приклад кодy (Глибоке копіювання)
 
Рисунок Б.11 – Висновки
 
Рисунок Б.12 – Використані джерела
 
ДОДАТОК В 
1 public interface IPrototype<T>
2 {
3     T Clone();
4 }
5 
6 public class UserSettings : IPrototype<UserSettings>
7 {
8    public string Theme { get; set; }
9    public int FontSize { get; set; }
10    public List<string> Shortcuts { get; set; }
11
12    public UserSettings Clone()
13    {
14        return new UserSettings
15        {
16            Theme = this.Theme,
17            FontSize = this.FontSize,
18            Shortcuts = new 
19 List<string>(this.Shortcuts)
20        };
21    }
22 }
23
24 var original = new UserSettings
25 {
26    Theme = "Dark",
27    FontSize = 14,
28    Shortcuts = new List<string>{"Ctrl+C","Ctrl+V"}
29 };
30
31 var copy = original.Clone();
32 copy.FontSize = 16;






